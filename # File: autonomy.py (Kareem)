# File: autonomy.py
import time, logging
from camera import Detection
from adafruit_servokit import ServoKit
from barometer import set_ground, get_height

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("autonomy")

class RobotState:
    def __init__(self):
        self.altitude_readings = []
        self.ground = set_ground()
        self.current_stop = 10
        self.cg_target = 10
        self.tracking = False
        self.mode = "manual"  # or "ball", "goal"
        self.last_times = {k:0 for k in ("wing","cg","alt")}

class Autonomy:
    def __init__(self):
        self.state = RobotState()
        self.camera = Detection(stream=False, testing=False)
        self.kit = ServoKit(channels=16)
        # Configure continuous servo 6
        self.kit.continuous_servo[6].set_pulse_width_range(1000,2300)

    def millis(self):
        return int(time.time()*1000)

    def update_altitude(self):
        now = self.millis()
        if now - self.state.last_times["alt"] < 3000:
            return
        self.state.last_times["alt"] = now
        h = get_height(self.state.ground)
        self.state.altitude_readings.append(h)
        if len(self.state.altitude_readings)>5:
            self.state.altitude_readings.pop(0)
        self.state.alt = sum(self.state.altitude_readings)/len(self.state.altitude_readings)

    def move_cg(self):
        # Simplified: step one stop toward target every 150ms
        now = self.millis()
        if now - self.state.last_times["cg"] < 150:
            return False
        self.state.last_times["cg"] = now
        curr = self.state.current_stop
        tgt = self.state.cg_target
        if curr == tgt:
            self.kit.continuous_servo[6].throttle = 0
            return True
        direction = 1 if tgt>curr else -1
        self.kit.continuous_servo[6].throttle = direction*0.2
        self.state.current_stop += direction
        return False

    def oscillate(self, direction, freq):
        angle = 90 + direction*80 * math.sin(2*math.pi*freq*time.time())
        return max(0, min(180, angle))

    def manual_control(self, inputs):
        # Example: D-pad up flaps
        now = self.millis()
        if inputs["dpad_up"] and now-self.state.last_times["wing"]>80:
            self.state.last_times["wing"] = now
            a = self.oscillate(1,0.8)
            self.kit.servo[0].angle = 180-a
            self.kit.servo[1].angle = a
        # CG rail
        if inputs["cg_forward"]:
            self.state.cg_target = max(1, self.state.cg_target-1)
        if inputs["cg_backward"]:
            self.state.cg_target = min(20, self.state.cg_target+1)
        self.move_cg()

    def search_and_track(self, target):
        """Generic search→track for ball (1) or goal (2)."""
        self.update_altitude()
        det = self.camera.detect(target)
        if det:
            # tracking
            nx, ny, area = det
            logger.info(f"Tracking target {target}: {det}")
            # adjust CG by z‐error (ny)
            if abs(ny) > 0.1:
                self.state.cg_target = 10 - int(ny*5)
                self.move_cg()
            # flap wings to center x
            now = self.millis()
            if abs(nx) > 0.1 and now-self.state.last_times["wing"]>80:
                self.state.last_times["wing"] = now
                direction = -1 if nx>0 else 1
                a = self.oscillate(direction, 0.6)
                self.kit.servo[0].angle, self.kit.servo[1].angle = a, 180-a
            return False  # keep running
        else:
            # simple “search” sweep
            now = self.millis()
            if now-self.state.last_times["wing"]<200:
                return False
            self.state.last_times["wing"] = now
            a = self.oscillate(1,0.4)
            self.kit.servo[0].angle, self.kit.servo[1].angle = a, 180-a
            return False

    def ball_search_loop(self):
        return self.search_and_track(1)

    def goal_search_loop(self):
        return self.search_and_track(2)

    def set_cg_ten(self):
        logger.info("Reset CG to 10")
        self.state.cg_target = 10
        self.state.current_stop = 10

robot = Autonomy()
